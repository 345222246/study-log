### 파일 불러오기
- file
	- GDB가 성공적으로 설치 되었다면, 터미널에서 gdb 명령어를 입력하여 GDB를 실행할 수 있다. 디버깅을 수행하기 위해 gdb 명령어로 디버깅 터미널을 생성한 뒤 가장 먼저 해야 할 일은 디버깅 할 바이너리를 gdb에 불러오는 것이다. file 명령어는 바이너리를 gdb에 불러 와 실행하고 디버깅 할 수 있게 한다. file 명령어 뒤에 불러 올 바이너리 경로를 넣어 사용할 수 있다. 처음 터미널에서 gdb를 실행할 때 gdb ./debugee와 같이 인자에 디버깅 할 바이너리 경로를 넣어도 동일한 기능을 수행한다. 
- `No debugging symbols found in ./debugee` 라고 표시되는 이유는 debugee 바이너리 안에 디버깅 정보가 포함되어 있지 않기 때문이다. 디버깅 정보를 포함하기 위해서는 컴파일 할 때 `-g` 옵션을 주어 컴파일 해야하지만, debugee 바이너리를 포함해서 해커들이 마주치는 대부분의 바이너리는 `-g` 옵션 없이 컴파일한 바이너리이다. 
- 이미 실행중인 프로세스를 GDB로 디버깅하기 
	- file 명령어에서 설명한 방법으로 바이너리를 불러오는 경우, GDB에서 해당 바이너리를 실행하여 디버깅을 수행하게 된다. 하지만 이미 실행 중인 프로세스를 디버깅하고 싶은 경우도 종종 있다. 이런 경우를 위해 GDB는 이미 실행 중인 프로세스의 PID 정보를 이용해 디버깅을 수행할 수 있는 방법을 제공하고 있다. `gdb -p <PID>`

### 실행 흐름 제어하기
- run 
	- 디버거는 기본적으로 프로그램을 실행시키면서 분석하는 도구이다. 실행 중 특정 지점에서의 프로세스 상태를 진단하고 버그를 찾게 도와준다. 본격적인 디버깅을 학습하기 이전에 GDB에서 프로그램을 실행하는 방법부터 배워보자 
	- run 명령어는 GDB에서 프로그램을 실행하는 명령어이다. r 명령어만 입력해도 run과 동일하게 실행될 수 있도록 하는 단축 명령어도 존재한다. 
	```gdb
	pwndbg> run <프로그램 인자>
	```

- break & continue
	- run 명령어를 실행하면, 단순히 프로그램을 실행하는 것과 별반 다르지 않다. 개발자는 디버거가 프로그램의 특정 명령어가 실행 되었을 때 어떤 일이 일어나는 지 구체적인 정보를 제공하기를 기대한다. 그래서 많은 디버거에는 break 와 continue 라는 명령어가 존재한다.
	- `break`는 특정 주소에 중단점을 설정하는 기능
	- `continue`는 중단된 프로그램은 계속 실행시키는 기능
	```gbd
	pwndbg> b main
	Breakpoint 1 at 0x401156

	pwndbg> b *0x401156
	Breakpoint 2 at 0x401156
	```

- entry & start
	- 리눅스는 실행파일 형식으로 ELF를 규정하고 있다. ELF는 크게 헤더와 여러 섹션들로 구성되어 있음. 헤더에는 실행에 필요한 여러 정보가 적혀 있고, 섹션들에는 컴파일된 기계어 코드, 프로그램 문자열을 비롯한 여러 데이터가 포함되어 있다. 
	- ELF의 헤더 중에 진입점이라는 필드가 있는데, 운영체제는 ELF를 실행할 때, 진입점의 명령어부터 프로그램을 실행한다. readelf 명령어로 확인해본 결과 debugee의 진입점은 0x401050 이다. 
	- `entry` 명령어는 진입점부터 프로그램을 분석할 수 있게 해주는 명령어이다. 출력된 결과에서 DISASM 부분의 화살표가 가리키는 주소는 rip 레지스터의 값으로 현재 실행 중인 명령어 주소인데, entry 명령어를 실행하고 보면 0x401050 을 가리키고 있다. 
	- entry 명령어와 유사하지만 프로그램의 진입점이 아닌 main() 부터 분석할 수 있는 명령어로 `start` 명령어가 있다. 

### 실행 흐름 추적하기
- 관찰하고자 하는 함수의 중단점에 도달했으면, 그 지점부터는 명령어를 한 줄 씩 자세히 분석해야 한다. 이때 사용하는 명령어로는 `ni` 와 `si` 가 있다. 
- 둘 다 어셈블리 명령어를 한 줄 실행한다는 공통점이 있다. 그러나 만약 call 어셈블리 명령어 등을 통해 함수를 호출하는 경우 ni는 함수 내부로 들어가지 않지만, si는 함수 내부로 들어간다는 차이점이 있다. 

### 디버깅을 위해 자주 사용하는 명령어들
- info
	- 정보를 보여주는 명령어이다. 
	- info registers: 프로그램이 실행 중일 때 사용할 수 있는 명령어이다. 레지스터의 값을 확인하고 싶을 때 사용된다. 
	- info breakpoints: 프로그램의 실행 여부와 상관 없이 사용할 수 있는 명령어이다. 
- disassemble
	- 프로그램의 코드는 기계어로 이루어져 있으므로, GDB는 기계어를 디스어셈블하는 기능을 기본적으로 탑재하고 있다. 
	- disassemble은 GDB가 기본적으로 제공하는 디스어셈블 명령어이다. 함수이름을 인자로 전달하면 해당 함수가 반환될 때 까지 전부 디스어셈블하여 보여준다. 
- x
	- 프로그램을 분석하다 보면 가상 메모리에 존재하는 임의 주소의 값을 관찰해야 할 때가 있다. 
	- x 를 이용하면 특정 주소에서 원하는 길이만큼의 데이털르 원하는 형식으로 인코딩하여 볼 수 있다. 
- telescope
	- pwndbg가 제공하는 강력한 메모리 덤프 기능이다. 특정 주소의 메모리 값들을 보여주는 것에 그치지 않고, 메모리가 참조하고 있는 주소를 재귀적으로 탐색하여 값을 보여준다. 
- vmmap
	- 가상 메모리의 레이아웃을 보여준다. 어떤 파일이 매핑 된 영역일 경우, 해당 파일의 경로까지 보여준다. 이 명령어는 프로그램이 실행된 상태에서 이용가능. 
>파일 매핑이란?
>어떤 파일을 메모리에 적재하는 것을 파일 매핑이라고 한다. 
>리눅스에는 ELF를 실행할 때, 먼저 ELF의 코드와 여러 데이터를 가상 메모리에 매핑하고, 해당 ELF에 링크된 공유 오브젝트를 추가로 메모리에 매핑한다. 공유 오브젝트는 윈도우의 DLL과 대응되는 개념으로, 자주 사용되는 함수들을 미리 컴파일해둔 것이다. 

- breaktrace
	- 콜 스택이란 프로그램이 실행되는 동안 함수가 호출되는 순서를 저장하는 구조이다. 프로그램이 실행되면서 하나의 함수가 다른 함수를 호출할 때 마다 새로운 함수 호출 정보가 추가되며, 함수 실행이 끝나면 가장 최근에 호출된 함수부터 순차적으로 제거된다. 
	- 콜 스택은 디버깅할 때 유용한 정보로 사용될 수 있다. 만약 어떤 함수에 전달된 인자에 문제가 발생해 버그가 발생했다면, 이 인자가 어떤 함수로부터 왔는지 거슬로 올라가면서 버그의 원인을 찾아야 하는데, 이 때 콜 스택이 유용하게 사용될 수 있다. 
	- GDB에서는 backtrace 혹은 bt 명령어를 이용해 콜 스택을 확인할 수 있다. 
- dump memory
	- 프로세스의 메모리 상태를 파일로 저장할 때 사용하는 명령어이다. 
- context
	- 프로그램이 실행되면서 레지스터를 비롯한 여러 메모리에 접근한다. 따라서 디버거를 이용하여 프로그램의 실행 과정을 자세히 관찰하려면 컴퓨터의 각종 메모리를 한눈에 파악할 수 있는 것이 좋다. pwndbg는 주요 메모리들의 상태를 프로그램이 실행되고 있는 맥락이라고 부르며, 이를 가독성 있게 표현할 수 있는 인터페이스를 갖추고 있다. 기본적으로 프로그램이 실행되다가 중단점에 도달하면 자동으로 실행되지만, 별도로 context 명령어를 입력하여 실행할 수도 있다. 
- set
	- 지금까지 알아본 GDB 기능들은 모두 프로세스에 관한 정보를 얻을 수 있는 명령어들이었다. 이번에 학습할 set 명령어는 프로세스의 메모리 상태를 변경할 수 있는 명령어이다. 
