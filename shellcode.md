
### 셸코드
- 익스플로잇을 위해 제작된 어셈블리 코드 조각을 일컫는다. 
- 일반적으로 셸을 획득하기 위한 목적
- 셸을 획득하는 것이 시스템 해킹의 관점에서 매우 중요
- 만약 해커가 rip을 자신이 작성한 셸코드로 옮길 수 있으면 해커는 원하는 어셈블리 코드가 실행되게 할 수 있다. 
- 어셈블리어는 기계어와 거의 일대일 대응되므로 사실상 원하는 모든 명령을 CPU에 내릴 수 있다. 
- 셸코드는 어셈블리어로 구성되므로 공격을 수행할 대상 아키텍처와 운영체제에 따라, 그리고 셸코드의 목적에 따라 다르게 작성됨. 

### orw 셸코드 작성
- orw 셸코드는 파일을 열고, 읽은 뒤 화면에 출력해주는 셸코드이다. 
- 구현하려는 셸코드의 동작을 c언어 형식으로 표현
```c
char buf[0x30];
// 48 바이트 크기의 문자 배열을 선언 (0x30=16진수로 48)
// 파일 내용을 저장할 버퍼 역할

int fd=open("/tmp/flag",RD_ONLY,NULL);
// /tmp/flag 파일을 읽기 전용으로 읽기
// fd는 파일 디스크립터를 저장
// NULL은 세 번째 매개 변수로, 일반적으로 권한 설정용이지만 여기서는 불필요

read(fd,buf,0x30);
// 열린 파일에서 최대 48바이트를 읽어서 buf 배열에 저장
// 실제로 읽은 바이트 수를 반환하지만 이 코드에서는 반환값을 사용하지 않음

write(1,buf,0x30);
// 출력 -> 화면에 파일 내용 표시
```

- orw 셸코드를 작성하기 위해 알아야 하는 syscall은 아래와 같다.
	
| syscall | rax  | arg0 (rdi)           | arg1 (rsi)      | arg2 (rdx)   |
| ------- | ---- | -------------------- | --------------- | ------------ |
| read    | 0x00 | unsigned int fd      | char *buf       | size_t count |
| write   | 0x01 | unsigned int fd      | const char *buf | size_t count |
| open    | 0x02 | const char *filename | int flag        | umode_t mode |
- read 시스템 콜
	- read(파일 디스크립터, 버퍼주소, 읽을크기)
	- rax=0: read 시스템 콜을 사용하겠다는 신호
	- rdi: 어떤 파일을 읽을지
	- rsi: 읽은 내용을 어디에 저장할지 (버퍼주소)
	- rdx: 몇 바이트 읽을지
- write 시스템 콜
	- write(파일 디스크립터, 버퍼주소, 쓸크기)
	- rax=1: write 시스템 콜을 사용하겠다는 신호
	- rdi: 어디에 쓸지
	- rsi: 쓸 내용이 있는 주소
	- rdx: 몇 바이트 쓸지
- open 시스템 콜
	- open( 파일명, 플래그, 권한)
	- rax=2: open 시스템 콜을 사용하겠다는 신호
	- rdi: 열고 싶은 파일 이름
	- rsi: 읽기만? 쓰기만? (플래그)
	- rdx: 파일 권한 설정

1. int fd=open("/tmp/flag",O_RDONLY,NULL)

| syscall | rax  | arg0(rdi)            | arg1(rsi) | arg2(rdx)    |
| ------- | ---- | -------------------- | --------- | ------------ |
| open    | 0x02 | const char *filename | int flags | umode_t mode |
- 첫 번째로 해야 할 일은 "/tmp/flag"라는 문자열을 메모리에 위치시키는 것
- 이를 위해 0x67616c662f706d742f (/tmp/flag 의 리틀 엔디안 형태)를 push하여 위치시키도록 만들어야한다.
- 하지만 스택에는 8 바이트 단위로만 값을 push할 수 있으므로 0x67를 우선 push한 후, 0x616c662f706d742f를 push 한다. 
- 그리고 rdi가 이를 가리키도록 rsp를 rdi로 옮긴다.
- O_RDONLY는 0이므로, rsi는 0으로 설정
- 파일을 읽을 때, mode는 의미를 갖지 않으므로, rdx는 0으로 설정
- 마지막으로 rax를 open의 syscall 값인 2로 설정
- 구현
```assembly
push 0x67
mov rax, 0x616c662f706d742f
push rax
mov rdi, rsp   ; rdi="/tmp/flag"
xor rsi, rsi   ; rsi=0; RD_ONLY
xor rdx, rdx   ; rdx=0
mov rax, 2     ; rax=2 ; syscall_open
syscall        ; open("/tmp/flag",RD_ONLY,NULL)
```
	
- xor는 레지스터를 0으로 만드는 효율적인 방법

- fd
	- 파일 서술자는 유닉스 계열의 운영체제에서 파일에 접근하는 소프트웨어에 제공하는 가상의 접근 제어자이다. 프로세스마다 고유의 서술자 테이블을 가지고 있으며, 그 안에 여러 파일 서술자를 저장한다. 

### orw 셸코드 컴파일 및 실행
- 대부분 운영체제는 실행 가능한 파일의 형식을 규정하고 있다. 

### execve 셸코드
- 셸이란 운영체제에 명령을 내리기 위해 사용되는 사용자의 인터페이스로, 운영체제의 핵심 기능을 하는 프로그램을 커널이라고 하는 것과 대비된다. 
- 셸을 획득하면 시스템을 제어할 수 있게 되므로 통상적으로 셸 획득을 시스템 해킹의 성공으로 여긴다.
- execve 셸코드는 임의의 프로그램을 실행하는 셸코드인데, 이를 이용하면 서버의 셸을 획득할 수 있다. 
- 다른 언급없이 셸코드라고 하면 이를 의미하는 경우가 많다. 
- 최신의 리눅스는 대부분 sh, bash를 기본 셸 프로그램으로 탑재
